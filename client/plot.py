## Python script to plot graphs generated by multibenchmark in benchmark.js.

import matplotlib
import matplotlib.pyplot as plt
from matplotlib import rcParams
import numpy as np
import json
f = open('measurement_100.json', 'r')
data = f.read()
print(data)

myjson = json.loads(data)
print (myjson)

tavg = []
for tval in myjson["tavg"]:
    print(tval)
    tavg.append(float(tval))
tsd = []
for tsdval in myjson["tsd"]:
    print(tsdval)
    tsd.append(float(tsdval))
tmin = []
for tmval in myjson["tmin"]:
    print(tmval)
    tmin.append(float(tmval))
respavg = []
for raval in myjson["respavg"]:
    print(raval)
    respavg.append(float(raval))
respsd = []
for rsdval in myjson["respsd"]:
    print(rsdval)
    respsd.append(float(rsdval))
fails = []
for fval in myjson["fails"]:
    print(fval)
    fails.append(float(fval))
tnum = []
for tnval in myjson["tnum"]:
    print(tnval)
    tnum.append(float(tnval))
tsize = []
for tsval in myjson["tsize"]:
    print(tsval)
    tsize.append(float(tsval))
samples = []
for sval in myjson["samples"]:
    print(sval)
    samples.append(float(sval))

## B data

f = open('measurement_100_noocs.json', 'r')
data = f.read()
print(data)

myjson = json.loads(data)
print (myjson)

btavg = []
for tval in myjson["tavg"]:
    print(tval)
    btavg.append(float(tval))
btsd = []
for tsdval in myjson["tsd"]:
    print(tsdval)
    btsd.append(float(tsdval))
btmin = []
for tmval in myjson["tmin"]:
    print(tmval)
    btmin.append(float(tmval))
brespavg = []
for raval in myjson["respavg"]:
    print(raval)
    brespavg.append(float(raval))
brespsd = []
for rsdval in myjson["respsd"]:
    print(rsdval)
    brespsd.append(float(rsdval))
bfails = []
for fval in myjson["fails"]:
    print(fval)
    bfails.append(float(fval))
btnum = []
for tnval in myjson["tnum"]:
    print(tnval)
    btnum.append(float(tnval))
btsize = []
for tsval in myjson["tsize"]:
    print(tsval)
    btsize.append(float(tsval))
bsamples = []
for sval in myjson["samples"]:
    print(sval)
    bsamples.append(float(sval))


rcParams.update({'figure.autolayout': True})
print("asdf")
plt.style.use('seaborn-paper')

print(tsize)

matplotlib.rc('xtick', labelsize=15) 
matplotlib.rc('ytick', labelsize=15) 

params = {'legend.fontsize': 13,
          'legend.handlelength': 2}
plt.rcParams.update(params)

fig, ( ax1, ax2) = plt.subplots(nrows=2, sharex=False)

ax1.errorbar(tsize, tmin, fmt='-o', label="With Off-Chain Storage")
ax1.errorbar(btsize, btmin, fmt='-d', label="Only Stored in Blockchain")
ax1.set_ylabel('tx/min')
plt.gca().legend(('With Off-Chain Storage','Only Stored in Blockchain'))

for item in ([ax1.title, ax1.xaxis.label, ax1.yaxis.label] +
             ax1.get_xticklabels() + ax1.get_yticklabels()):
    item.set_fontsize(13)

ax2.errorbar(tsize, respavg, yerr=respsd, fmt='-o', label="With Off-Chain Storage")
ax2.errorbar(btsize, brespavg, yerr=brespsd, fmt='-d', label="Only Stored in Blockchain")
ax2.set_ylabel('respone time (ms)')
ax2.set_xlabel('file size (bytes)')

plt.gca().legend(('With storage','Only blockchain'))

for item in ([ax2.title, ax2.xaxis.label, ax2.yaxis.label] +
             ax2.get_xticklabels() + ax2.get_yticklabels()):
    item.set_fontsize(13)



plt.show()
